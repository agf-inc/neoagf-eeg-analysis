#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <map>
#include <stdexcept>
#include "ACT.h"

// Function to load signal from a text file
std::vector<double> load_signal(const std::string& filename) {
    std::vector<double> signal;
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Could not open signal file: " + filename);
    }
    double value;
    while (file >> value) {
        signal.push_back(value);
    }
    return signal;
}

// Robust parser for the specific JSON format of debug_params.json
ACT::ParameterRanges load_ranges(const std::string& filename) {
    std::map<std::string, double> params;
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("Could not open params file: " + filename);
    }

    std::string line;
    while (std::getline(file, line)) {
        // Find the key within quotes
        size_t first_quote = line.find('"');
        if (first_quote == std::string::npos) continue;
        size_t second_quote = line.find('"', first_quote + 1);
        if (second_quote == std::string::npos) continue;

        std::string key = line.substr(first_quote + 1, second_quote - first_quote - 1);

        // Find the value after the colon
        size_t colon = line.find(':');
        if (colon == std::string::npos) continue;

        std::string value_str = line.substr(colon + 1);
        
        try {
            double value = std::stod(value_str);
            params[key] = value;
        } catch (const std::invalid_argument& ia) {
            // Ignore lines that don't have a valid number, like '{' or '}'
        }
    }

    ACT::ParameterRanges r;
    r.tc_min = params.at("tc_min");
    r.tc_max = params.at("tc_max");
    r.tc_step = params.at("tc_step");
    r.fc_min = params.at("fc_min");
    r.fc_max = params.at("fc_max");
    r.fc_step = params.at("fc_step");
    r.logDt_min = params.at("logDt_min");
    r.logDt_max = params.at("logDt_max");
    r.logDt_step = params.at("logDt_step");
    r.c_min = params.at("c_min");
    r.c_max = params.at("c_max");
    r.c_step = params.at("c_step");

    return r;
}

int main() {
    try {
        std::cout << "--- C++ ALGLIB Debug Test ---" << std::endl;

        // Load data from files generated by Python
        std::vector<double> signal = load_signal("python/debug_signal.txt");
        ACT::ParameterRanges ranges = load_ranges("python/debug_params.json");

        std::cout << "Signal loaded with " << signal.size() << " samples." << std::endl;
        std::cout << "Parameter ranges loaded successfully." << std::endl;

        // Hardcoded values from rbf_train.py
        double fs = 150.0;
        int length = 256;

        if (signal.size() != length) {
            std::cerr << "Error: Signal length mismatch. Expected " << length << ", got " << signal.size() << std::endl;
            return 1;
        }

        // Initialize ACT engine
        ACT act_engine(fs, length, "dict_cache.bin", ranges, false, false, false);

        // --- First Transform Call ---
        std::cout << "\nRunning FIRST ACT::transform call..." << std::endl;
        ACT::TransformResult result1 = act_engine.transform(signal, 1, true);

        std::cout << "\n--- First Transform Complete ---" << std::endl;
        if (result1.params.empty()) {
            std::cout << "Result: No chirplets found." << std::endl;
        } else {
            std::cout << "Result: Top chirplet found with coefficient " << result1.coeffs[0] << std::endl;
        }

        // --- Second Transform Call ---
        std::cout << "\n\nRunning SECOND ACT::transform call on the SAME engine instance..." << std::endl;
        ACT::TransformResult result2 = act_engine.transform(signal, 1, true);

        std::cout << "\n--- Second Transform Complete ---" << std::endl;
        if (result2.params.empty()) {
            std::cout << "Result: No chirplets found." << std::endl;
        } else {
            std::cout << "Result: Top chirplet found with coefficient " << result2.coeffs[0] << std::endl;
        }

    } catch (const std::exception& e) {
        std::cerr << "An error occurred: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
